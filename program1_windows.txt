-- Program #1 description: a program that reads 20 numbers (integers) from the keyboard, 
-- prints the numbers to the console printer, requests a number from the user, 
-- and searches the 20 numbers read in for the number closest to the number entered by the user. 
-- Print the number entered by the user and the number closest to that number. 
-- Your numbers should not be 1…10, but distributed over the range of 1 … 65,536. 
-- Therefore, as you read a character in, you need to check it is a digit, convert it to a number, and assemble the integer.
-- initial PC = 1000
-- Usage of the MEM Location:
-- 1  temp
--	2	R0
--	3	R1
--	4	R2
--	5	R3
--	6	PC
--	7	temp
--	8	temp
--	9	object number
-- 10	result
-- 11 ~ 30   20 numbers
-- 31 temp

** Program name: comparison of numbers
** Phases to operate this program:
** (1) Follow the instruction to enter 20 numbers one by one, each number will be displayed on the screen starting with a symbol '#';
** (2) Then, enter the number you plan to compare it with the 20 numbers above, this number will also be displayed with symbols '##'; 
** (3) After a period of time for calculation, the number you entered in Phase2 and the result will be displayed on the screen with symbols '###';
** (4) Therefore, the last sentence starting with '###' is the answer you expect to know.
** Note:
** (1) 
-- store current R0-R3 into memory
STR 0,0,2
SMR 0,0,2
STR 1,0,3
SMR 1,0,3
STR 2,0,4
SMR 2,0,4
STR 3,0,5
SMR 3,0,5

-- initialize the first location of numbers
AIR 1,11
-- initialize the number of numbers, here is 20 numbers
-- it's also the count of loops
AIR 2,20

-- part 1: get the user's inputs, including 20 numbers and 1 object number
-- record the PC value as jump location
STR 1,0,8
IN 3,7
SIR 3,3
STR 3,0,6

-- print a '#' onto screen
STR 0,0,1
SMR 0,0,1
AIR 0,5
AIR 0,30
OUT 0,1

-- get one of the 20 numbers
IN 0,0
OUT 0,0

-- print a '\n' onto screen
STR 0,0,8,1
STR 0,0,1
SMR 0,0,1
AIR 0,10
OUT 0,1

-- loop count +1; R2 = R2 -1; if R2 >=0, jump
AIR 1,1
STR 1,0,8
SOB 2,0,6,1

-- print '##' onto screen
STR 0,0,1
SMR 0,0,1
AIR 0,5
AIR 0,30
OUT 0,1
OUT 0,1

-- get the object number
IN 0,0
OUT 0,0
STR 0,0,9
STR 0,0,1

-- print a '\n' onto screen
SMR 0,0,1
AIR 0,10
OUT 0,1


-- part 2: calculation
-- clear R0-R3
STR 0,0,7
SMR 0,0,7
STR 1,0,7
SMR 1,0,7
STR 2,0,7
SMR 2,0,7
STR 3,0,7
SMR 3,0,7

-- initialize the count of loops, or the number of numbers
AIR 2,20
-- initialize the first location of the 20 numbers
AIR 3,11
-- Set a maxnum value(01111111 11111111) for Mem(8), which is used to store the smallest difference between numbers and object number
STR 3,0,7
SMR 3,0,7
NOT 3
SRC 3,1,0,1
STR 3,0,8
LDR 3,0,7

-- record the current PC value for jump
IN 3,7
SIR 3,4
STR 3,0,6
LDR 3,0,7

-- Get one of the numebrs from memory, and use object number minus it 
LDR 0,0,7,1
LDR 1,0,9
SMR 1,0,7,1

-- record jump location for JGE1
STR 0,0,1
IN 0,7
SIR 0,8
STR 0,0,11
LDR 0,0,1

-- if the value in R1 < 0, R1 minus itself twice; or jump
JGE 1,0,11,1
STR 1,0,1
SMR 1,0,1
SMR 1,0,1
STR 1,0,31

-- use the R1 minus the smallest difference until now
SMR 1,0,8

-- record the jump location for JGE2
STR 0,0,1
IN 0,7
SIR 0,8
STR 0,0,11
LDR 0,0,1

-- if the difference between current number and the object number is smaller than the smallest difference until now
-- use the difference to replace the smallest difference
-- use the current number as the result
-- else, jump, do nothing
JGE 1,0,11,1
LDR 1,0,31
STR 1,0,8
STR 0,0,10
AIR 3,1
STR 3,0,7

SOB 2,0,6,1

-- part 3: display result
-- clear R0-R2
STR 0,0,7
SMR 0,0,7
STR 1,0,7
SMR 1,0,7
STR 2,0,7
SMR 2,0,7

AIR 2,10

-- print '###' onto screen
AIR 0,5
AIR 0,30
OUT 0,1
OUT 0,1
OUT 0,1

-- print the object number
LDR 1,0,9
OUT 1,0

-- print '\n' onto screen
OUT 2,1

-- print '###' onto screen
OUT 0,1
OUT 0,1
OUT 0,1

-- print the number that is cloest to the object number
LDR 1,0,10
OUT 1,0

-- print '\n' onto screen
OUT 2,1

-- part 4: restore R0,R1,R2,R3
LDR 0,0,2
LDR 1,0,3
LDR 2,0,4
LDR 3,0,5



